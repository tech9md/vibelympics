"""Vulnerability analyzer using OSV API."""
import httpx
from typing import Dict, Any, List, Optional
from app.logging_config import get_logger
from app.analyzers.base import BaseAnalyzer, AnalyzerResult, Finding, SeverityLevel
from app.config import settings
from app.utils.cache import osv_cache

logger = get_logger(__name__)


class VulnerabilityAnalyzer(BaseAnalyzer):
    """Analyze packages for known vulnerabilities using OSV database."""

    category = "vulnerability"
    weight = 0.25

    def __init__(self):
        self.osv_url = settings.osv_api_url

    async def analyze(
        self,
        package_name: str,
        version: str,
        package_metadata: Dict[str, Any],
        extracted_path: Optional[str] = None,
    ) -> AnalyzerResult:
        """Check for known vulnerabilities in OSV database."""
        findings = []

        # Query OSV for vulnerabilities
        vulns = await self._query_osv(package_name, version)

        for vuln in vulns:
            severity = self._map_severity(vuln)
            finding = Finding(
                category=self.category,
                severity=severity,
                title=f"{vuln.get('id', 'Unknown')}: {self._get_summary(vuln)}",
                description=vuln.get("details", vuln.get("summary", "No description available")),
                remediation=self._get_remediation(vuln),
                references=self._get_references(vuln),
                metadata={
                    "vuln_id": vuln.get("id"),
                    "aliases": vuln.get("aliases", []),
                    "affected_versions": self._get_affected_versions(vuln),
                    "fixed_version": self._get_fixed_version(vuln),
                    "cvss_score": self._get_cvss_score(vuln),
                    "published": vuln.get("published"),
                    "modified": vuln.get("modified"),
                },
            )
            findings.append(finding)

        # Also check dependencies for vulnerabilities
        dep_findings = await self._check_dependency_vulns(package_metadata)
        findings.extend(dep_findings)

        return AnalyzerResult(
            category=self.category,
            findings=findings,
            metadata={
                "total_vulnerabilities": len(vulns),
                "dependency_vulnerabilities": len(dep_findings),
            },
        )

    @osv_cache.cache_async
    async def _query_osv(self, package_name: str, version: str) -> List[Dict[str, Any]]:
        """Query OSV API for vulnerabilities (cached for 1 hour)."""
        url = f"{self.osv_url}/query"

        payload = {
            "package": {
                "name": package_name,
                "ecosystem": "PyPI",
            },
            "version": version,
        }

        try:
            logger.debug(f"Querying OSV API for vulnerabilities: {package_name}@{version}")
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.post(url, json=payload)
                response.raise_for_status()
                data = response.json()
                vulns = data.get("vulns", [])
                logger.info(f"OSV API returned {len(vulns)} vulnerabilities for {package_name}@{version}")
                return vulns
        except Exception as e:
            logger.error(f"OSV API query failed for {package_name}@{version}: {e}")
            return []

    async def _check_dependency_vulns(
        self, package_metadata: Dict[str, Any]
    ) -> List[Finding]:
        """Check direct dependencies for known vulnerabilities."""
        findings = []
        requires_dist = package_metadata.get("requires_dist", []) or []

        for dep in requires_dist[:10]:  # Limit to first 10 deps for performance
            dep_name = self._parse_dependency_name(dep)
            if not dep_name:
                continue

            # Query OSV without version (get any vulnerabilities)
            vulns = await self._query_osv_package(dep_name)

            if vulns:
                finding = Finding(
                    category=self.category,
                    severity=SeverityLevel.MEDIUM,
                    title=f"Dependency '{dep_name}' has known vulnerabilities",
                    description=f"The dependency '{dep_name}' has {len(vulns)} known vulnerability(ies). Review and update if necessary.",
                    remediation=f"Check if your version of '{dep_name}' is affected and update to a patched version.",
                    metadata={
                        "dependency": dep_name,
                        "vulnerability_count": len(vulns),
                        "vulnerability_ids": [v.get("id") for v in vulns],  # Include all vulnerability IDs
                    },
                )
                findings.append(finding)

        return findings

    async def _query_osv_package(self, package_name: str) -> List[Dict[str, Any]]:
        """Query OSV for any vulnerabilities affecting a package."""
        url = f"{self.osv_url}/query"

        payload = {
            "package": {
                "name": package_name,
                "ecosystem": "PyPI",
            },
        }

        try:
            logger.debug(f"Querying OSV API for package vulnerabilities: {package_name}")
            async with httpx.AsyncClient(timeout=15.0) as client:
                response = await client.post(url, json=payload)
                if response.status_code == 200:
                    data = response.json()
                    vulns = data.get("vulns", [])
                    logger.debug(f"OSV API returned {len(vulns)} vulnerabilities for package {package_name}")
                    return vulns
        except Exception as e:
            logger.warning(f"OSV API query failed for package {package_name}: {e}")
        return []

    def _parse_dependency_name(self, dep_spec: str) -> Optional[str]:
        """Parse dependency name from requirement spec."""
        if not dep_spec:
            return None

        # Remove extras and version specifiers
        name = dep_spec.split("[")[0].split(";")[0].split("<")[0].split(">")[0]
        name = name.split("=")[0].split("!")[0].split("~")[0]
        return name.strip().lower()

    def _map_severity(self, vuln: Dict[str, Any]) -> SeverityLevel:
        """Map OSV severity to our severity levels."""
        # Check database_specific for CVSS
        cvss_score = self._get_cvss_score(vuln)
        if cvss_score:
            if cvss_score >= 9.0:
                return SeverityLevel.CRITICAL
            elif cvss_score >= 7.0:
                return SeverityLevel.HIGH
            elif cvss_score >= 4.0:
                return SeverityLevel.MEDIUM
            else:
                return SeverityLevel.LOW

        # Check severity field
        severity = vuln.get("severity", [])
        if severity:
            sev_type = severity[0].get("type", "").upper()
            sev_score = severity[0].get("score", "")

            if "CRITICAL" in sev_score.upper() or (sev_type == "CVSS_V3" and self._parse_cvss(sev_score) >= 9):
                return SeverityLevel.CRITICAL
            elif "HIGH" in sev_score.upper() or (sev_type == "CVSS_V3" and self._parse_cvss(sev_score) >= 7):
                return SeverityLevel.HIGH
            elif "MEDIUM" in sev_score.upper() or (sev_type == "CVSS_V3" and self._parse_cvss(sev_score) >= 4):
                return SeverityLevel.MEDIUM

        # Default based on presence of CVE
        if any(a.startswith("CVE-") for a in vuln.get("aliases", [])):
            return SeverityLevel.MEDIUM

        return SeverityLevel.LOW

    def _parse_cvss(self, cvss_string: str) -> float:
        """Parse CVSS score from vector string."""
        try:
            # Try to extract score from vector
            if "/" in cvss_string:
                parts = cvss_string.split("/")
                for part in parts:
                    if ":" not in part:
                        return float(part)
            return float(cvss_string)
        except (ValueError, TypeError):
            return 0.0

    def _get_cvss_score(self, vuln: Dict[str, Any]) -> Optional[float]:
        """Extract CVSS score from vulnerability."""
        severity = vuln.get("severity", [])
        for sev in severity:
            if sev.get("type") == "CVSS_V3":
                return self._parse_cvss(sev.get("score", ""))
        return None

    def _get_summary(self, vuln: Dict[str, Any]) -> str:
        """Get vulnerability summary."""
        return vuln.get("summary", vuln.get("id", "Unknown vulnerability"))[:200]

    def _get_affected_versions(self, vuln: Dict[str, Any]) -> str:
        """Get affected version range."""
        affected = vuln.get("affected", [])
        if affected:
            ranges = affected[0].get("ranges", [])
            if ranges:
                events = ranges[0].get("events", [])
                introduced = None
                fixed = None
                for event in events:
                    if "introduced" in event:
                        introduced = event["introduced"]
                    if "fixed" in event:
                        fixed = event["fixed"]
                if introduced and fixed:
                    return f">={introduced}, <{fixed}"
                elif introduced:
                    return f">={introduced}"
        return "Unknown"

    def _get_fixed_version(self, vuln: Dict[str, Any]) -> Optional[str]:
        """Get fixed version if available."""
        affected = vuln.get("affected", [])
        if affected:
            ranges = affected[0].get("ranges", [])
            if ranges:
                events = ranges[0].get("events", [])
                for event in events:
                    if "fixed" in event:
                        return event["fixed"]
        return None

    def _get_remediation(self, vuln: Dict[str, Any]) -> str:
        """Generate remediation advice."""
        fixed = self._get_fixed_version(vuln)
        if fixed:
            return f"Upgrade to version {fixed} or later."
        return "Check for available patches or consider alternative packages."

    def _get_references(self, vuln: Dict[str, Any]) -> List[str]:
        """Get reference URLs."""
        refs = vuln.get("references", [])
        return [r.get("url") for r in refs if r.get("url")][:5]
