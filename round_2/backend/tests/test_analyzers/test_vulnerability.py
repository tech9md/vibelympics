"""Unit tests for vulnerability analyzer."""
import pytest
from unittest.mock import AsyncMock, patch, MagicMock
import httpx
from app.analyzers.vulnerability import VulnerabilityAnalyzer
from app.analyzers.base import SeverityLevel
from app.utils.cache import osv_cache


@pytest.mark.unit
@pytest.mark.asyncio
class TestVulnerabilityAnalyzer:
    """Tests for VulnerabilityAnalyzer."""

    @pytest.fixture
    def analyzer(self):
        """Create analyzer instance."""
        return VulnerabilityAnalyzer()

    @pytest.fixture
    def sample_metadata(self):
        """Sample package metadata."""
        return {
            "name": "test-package",
            "version": "1.0.0",
            "requires_dist": [
                "requests>=2.0.0",
                "flask<3.0",
                "django>=3.0,<4.0",
            ],
        }

    @pytest.fixture
    def sample_vulnerability(self):
        """Sample OSV vulnerability response."""
        return {
            "id": "GHSA-xxxx-yyyy-zzzz",
            "summary": "Critical vulnerability in test-package",
            "details": "This is a detailed description of the vulnerability.",
            "aliases": ["CVE-2023-12345"],
            "severity": [
                {
                    "type": "CVSS_V3",
                    "score": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                }
            ],
            "affected": [
                {
                    "package": {
                        "ecosystem": "PyPI",
                        "name": "test-package",
                    },
                    "ranges": [
                        {
                            "type": "ECOSYSTEM",
                            "events": [
                                {"introduced": "0"},
                                {"fixed": "1.2.0"},
                            ],
                        }
                    ],
                }
            ],
            "references": [
                {"type": "ADVISORY", "url": "https://github.com/advisories/GHSA-xxxx"},
                {"type": "WEB", "url": "https://nvd.nist.gov/vuln/detail/CVE-2023-12345"},
            ],
            "published": "2023-05-15T10:00:00Z",
            "modified": "2023-05-16T12:00:00Z",
        }

    @pytest.fixture(autouse=True)
    def clear_cache(self):
        """Clear cache before each test."""
        osv_cache.clear()
        yield
        osv_cache.clear()

    async def test_query_osv_success(self, analyzer, sample_vulnerability):
        """Test successful OSV API query."""
        mock_response = MagicMock()
        mock_response.json.return_value = {"vulns": [sample_vulnerability]}
        mock_response.raise_for_status = MagicMock()

        with patch("httpx.AsyncClient") as mock_client:
            mock_client.return_value.__aenter__.return_value.post = AsyncMock(
                return_value=mock_response
            )

            vulns = await analyzer._query_osv("test-package", "1.0.0")

            assert len(vulns) == 1
            assert vulns[0]["id"] == "GHSA-xxxx-yyyy-zzzz"
            assert "CVE-2023-12345" in vulns[0]["aliases"]

    async def test_query_osv_empty_response(self, analyzer):
        """Test OSV API returns no vulnerabilities."""
        mock_response = MagicMock()
        mock_response.json.return_value = {"vulns": []}
        mock_response.raise_for_status = MagicMock()

        with patch("httpx.AsyncClient") as mock_client:
            mock_client.return_value.__aenter__.return_value.post = AsyncMock(
                return_value=mock_response
            )

            vulns = await analyzer._query_osv("safe-package", "1.0.0")

            assert len(vulns) == 0

    async def test_query_osv_network_error(self, analyzer):
        """Test OSV API network error handling."""
        with patch("httpx.AsyncClient") as mock_client:
            mock_client.return_value.__aenter__.return_value.post = AsyncMock(
                side_effect=httpx.RequestError("Network error")
            )

            vulns = await analyzer._query_osv("test-package", "1.0.0")

            # Should return empty list on error
            assert vulns == []

    async def test_query_osv_timeout(self, analyzer):
        """Test OSV API timeout handling."""
        with patch("httpx.AsyncClient") as mock_client:
            mock_client.return_value.__aenter__.return_value.post = AsyncMock(
                side_effect=httpx.TimeoutException("Request timed out")
            )

            vulns = await analyzer._query_osv("test-package", "1.0.0")

            # Should return empty list on timeout
            assert vulns == []

    async def test_query_osv_http_error(self, analyzer):
        """Test OSV API HTTP error handling."""
        mock_response = MagicMock()
        mock_response.raise_for_status.side_effect = httpx.HTTPStatusError(
            "404 Not Found",
            request=MagicMock(),
            response=MagicMock(),
        )

        with patch("httpx.AsyncClient") as mock_client:
            mock_client.return_value.__aenter__.return_value.post = AsyncMock(
                return_value=mock_response
            )

            vulns = await analyzer._query_osv("test-package", "1.0.0")

            # Should return empty list on HTTP error
            assert vulns == []

    async def test_analyze_with_vulnerabilities(self, analyzer, sample_metadata, sample_vulnerability):
        """Test analysis with vulnerabilities found."""
        mock_response = MagicMock()
        mock_response.json.return_value = {"vulns": [sample_vulnerability]}
        mock_response.raise_for_status = MagicMock()

        with patch("httpx.AsyncClient") as mock_client:
            mock_client.return_value.__aenter__.return_value.post = AsyncMock(
                return_value=mock_response
            )

            result = await analyzer.analyze(
                "test-package",
                "1.0.0",
                sample_metadata
            )

            assert result.category == "vulnerability"
            assert len(result.findings) > 0

            # Check first finding
            finding = result.findings[0]
            assert "GHSA-xxxx-yyyy-zzzz" in finding.title
            assert finding.severity in [SeverityLevel.CRITICAL, SeverityLevel.HIGH, SeverityLevel.MEDIUM]
            assert "CVE-2023-12345" in finding.metadata["aliases"]
            assert finding.metadata["fixed_version"] == "1.2.0"

    async def test_analyze_no_vulnerabilities(self, analyzer, sample_metadata):
        """Test analysis with no vulnerabilities found."""
        mock_response = MagicMock()
        mock_response.json.return_value = {"vulns": []}
        mock_response.raise_for_status = MagicMock()

        with patch("httpx.AsyncClient") as mock_client:
            mock_client.return_value.__aenter__.return_value.post = AsyncMock(
                return_value=mock_response
            )

            result = await analyzer.analyze(
                "safe-package",
                "1.0.0",
                sample_metadata
            )

            assert result.category == "vulnerability"
            # Should have no vulnerability findings (may have dependency findings)
            assert result.metadata["total_vulnerabilities"] == 0

    async def test_severity_mapping_critical(self, analyzer):
        """Test CVSS score mapping to CRITICAL severity."""
        vuln = {
            "id": "VULN-001",
            "severity": [{"type": "CVSS_V3", "score": "9.8"}],
        }

        severity = analyzer._map_severity(vuln)
        assert severity == SeverityLevel.CRITICAL

    async def test_severity_mapping_high(self, analyzer):
        """Test CVSS score mapping to HIGH severity."""
        vuln = {
            "id": "VULN-002",
            "severity": [{"type": "CVSS_V3", "score": "7.5"}],
        }

        severity = analyzer._map_severity(vuln)
        assert severity == SeverityLevel.HIGH

    async def test_severity_mapping_medium(self, analyzer):
        """Test CVSS score mapping to MEDIUM severity."""
        vuln = {
            "id": "VULN-003",
            "severity": [{"type": "CVSS_V3", "score": "5.0"}],
        }

        severity = analyzer._map_severity(vuln)
        assert severity == SeverityLevel.MEDIUM

    async def test_severity_mapping_low(self, analyzer):
        """Test CVSS score mapping to LOW severity."""
        vuln = {
            "id": "VULN-004",
            "severity": [{"type": "CVSS_V3", "score": "2.5"}],
        }

        severity = analyzer._map_severity(vuln)
        assert severity == SeverityLevel.LOW

    async def test_severity_mapping_with_cve_no_score(self, analyzer):
        """Test severity defaults to MEDIUM when CVE present but no score."""
        vuln = {
            "id": "VULN-005",
            "aliases": ["CVE-2023-99999"],
        }

        severity = analyzer._map_severity(vuln)
        assert severity == SeverityLevel.MEDIUM

    async def test_severity_mapping_no_cve_no_score(self, analyzer):
        """Test severity defaults to LOW when no CVE and no score."""
        vuln = {
            "id": "VULN-006",
            "aliases": [],
        }

        severity = analyzer._map_severity(vuln)
        assert severity == SeverityLevel.LOW

    async def test_parse_cvss_from_vector_string(self, analyzer):
        """Test parsing CVSS score from vector string."""
        cvss_vector = "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
        score = analyzer._parse_cvss(cvss_vector)
        # Vector doesn't contain explicit score, should return 0.0
        assert score == 0.0

        # Test with explicit score
        score = analyzer._parse_cvss("9.8")
        assert score == 9.8

    async def test_parse_cvss_invalid_input(self, analyzer):
        """Test CVSS parsing with invalid input."""
        assert analyzer._parse_cvss("invalid") == 0.0
        assert analyzer._parse_cvss("") == 0.0
        assert analyzer._parse_cvss(None) == 0.0

    async def test_get_cvss_score(self, analyzer):
        """Test extracting CVSS score from vulnerability."""
        vuln = {
            "severity": [
                {"type": "CVSS_V3", "score": "7.5"},
                {"type": "OTHER", "score": "HIGH"},
            ]
        }

        score = analyzer._get_cvss_score(vuln)
        assert score == 7.5

    async def test_get_cvss_score_no_cvss(self, analyzer):
        """Test CVSS score extraction when not present."""
        vuln = {
            "severity": [
                {"type": "OTHER", "score": "HIGH"},
            ]
        }

        score = analyzer._get_cvss_score(vuln)
        assert score is None

    async def test_get_affected_versions(self, analyzer):
        """Test extracting affected version range."""
        vuln = {
            "affected": [
                {
                    "ranges": [
                        {
                            "events": [
                                {"introduced": "1.0.0"},
                                {"fixed": "1.2.0"},
                            ]
                        }
                    ]
                }
            ]
        }

        affected = analyzer._get_affected_versions(vuln)
        assert affected == ">=1.0.0, <1.2.0"

    async def test_get_affected_versions_no_fixed(self, analyzer):
        """Test affected versions with no fixed version."""
        vuln = {
            "affected": [
                {
                    "ranges": [
                        {
                            "events": [
                                {"introduced": "0"},
                            ]
                        }
                    ]
                }
            ]
        }

        affected = analyzer._get_affected_versions(vuln)
        assert affected == ">=0"

    async def test_get_fixed_version(self, analyzer):
        """Test extracting fixed version."""
        vuln = {
            "affected": [
                {
                    "ranges": [
                        {
                            "events": [
                                {"introduced": "0"},
                                {"fixed": "2.0.0"},
                            ]
                        }
                    ]
                }
            ]
        }

        fixed = analyzer._get_fixed_version(vuln)
        assert fixed == "2.0.0"

    async def test_get_fixed_version_none(self, analyzer):
        """Test when no fixed version exists."""
        vuln = {
            "affected": [
                {
                    "ranges": [
                        {
                            "events": [
                                {"introduced": "0"},
                            ]
                        }
                    ]
                }
            ]
        }

        fixed = analyzer._get_fixed_version(vuln)
        assert fixed is None

    async def test_get_remediation_with_fix(self, analyzer):
        """Test remediation generation with fixed version."""
        vuln = {
            "affected": [
                {
                    "ranges": [
                        {
                            "events": [
                                {"fixed": "1.5.0"},
                            ]
                        }
                    ]
                }
            ]
        }

        remediation = analyzer._get_remediation(vuln)
        assert "1.5.0" in remediation
        assert "Upgrade" in remediation

    async def test_get_remediation_no_fix(self, analyzer):
        """Test remediation generation without fixed version."""
        vuln = {"affected": []}

        remediation = analyzer._get_remediation(vuln)
        assert "patches" in remediation.lower() or "alternative" in remediation.lower()

    async def test_get_references(self, analyzer):
        """Test extracting reference URLs."""
        vuln = {
            "references": [
                {"type": "ADVISORY", "url": "https://example.com/advisory"},
                {"type": "WEB", "url": "https://example.com/details"},
                {"type": "REPORT", "url": "https://example.com/report"},
            ]
        }

        refs = analyzer._get_references(vuln)
        assert len(refs) == 3
        assert "https://example.com/advisory" in refs

    async def test_get_references_limit(self, analyzer):
        """Test reference URL limit to 5."""
        vuln = {
            "references": [
                {"url": f"https://example.com/{i}"}
                for i in range(10)
            ]
        }

        refs = analyzer._get_references(vuln)
        assert len(refs) == 5

    async def test_parse_dependency_name(self, analyzer):
        """Test parsing dependency names from requirement specs."""
        assert analyzer._parse_dependency_name("requests>=2.0.0") == "requests"
        assert analyzer._parse_dependency_name("flask<3.0") == "flask"
        assert analyzer._parse_dependency_name("django>=3.0,<4.0") == "django"
        assert analyzer._parse_dependency_name("pytest[dev]>=6.0") == "pytest"
        assert analyzer._parse_dependency_name("package; python_version >= '3.7'") == "package"
        assert analyzer._parse_dependency_name("numpy~=1.20") == "numpy"
        assert analyzer._parse_dependency_name("scipy!=1.5.0") == "scipy"

    async def test_parse_dependency_name_empty(self, analyzer):
        """Test parsing empty dependency."""
        assert analyzer._parse_dependency_name("") is None
        assert analyzer._parse_dependency_name(None) is None

    async def test_check_dependency_vulns(self, analyzer):
        """Test checking dependencies for vulnerabilities."""
        metadata = {
            "requires_dist": [
                "vulnerable-package>=1.0.0",
                "safe-package>=2.0.0",
            ]
        }

        vulnerable_vuln = {
            "id": "GHSA-dep-vuln",
            "summary": "Vulnerability in dependency",
        }

        mock_response_vulnerable = MagicMock()
        mock_response_vulnerable.json.return_value = {"vulns": [vulnerable_vuln]}
        mock_response_vulnerable.status_code = 200

        mock_response_safe = MagicMock()
        mock_response_safe.json.return_value = {"vulns": []}
        mock_response_safe.status_code = 200

        with patch("httpx.AsyncClient") as mock_client:
            async def mock_post(url, json=None, **kwargs):
                if json["package"]["name"] == "vulnerable-package":
                    return mock_response_vulnerable
                return mock_response_safe

            mock_client.return_value.__aenter__.return_value.post = AsyncMock(
                side_effect=mock_post
            )

            findings = await analyzer._check_dependency_vulns(metadata)

            # Should find vulnerability in vulnerable-package
            assert len(findings) > 0
            assert any("vulnerable-package" in f.title for f in findings)
            assert all(f.severity == SeverityLevel.MEDIUM for f in findings)

    async def test_check_dependency_vulns_limit(self, analyzer):
        """Test dependency checking limits to first 10."""
        metadata = {
            "requires_dist": [f"package{i}>=1.0.0" for i in range(20)]
        }

        mock_response = MagicMock()
        mock_response.json.return_value = {"vulns": []}
        mock_response.status_code = 200

        with patch("httpx.AsyncClient") as mock_client:
            call_count = 0

            async def mock_post(url, json=None, **kwargs):
                nonlocal call_count
                call_count += 1
                return mock_response

            mock_client.return_value.__aenter__.return_value.post = AsyncMock(
                side_effect=mock_post
            )

            await analyzer._check_dependency_vulns(metadata)

            # Should only check first 10 dependencies
            assert call_count <= 10

    async def test_analyze_metadata_structure(self, analyzer, sample_metadata):
        """Test that analyze returns proper metadata structure."""
        mock_response = MagicMock()
        mock_response.json.return_value = {"vulns": []}
        mock_response.raise_for_status = MagicMock()

        with patch("httpx.AsyncClient") as mock_client:
            mock_client.return_value.__aenter__.return_value.post = AsyncMock(
                return_value=mock_response
            )

            result = await analyzer.analyze(
                "test-package",
                "1.0.0",
                sample_metadata
            )

            assert "total_vulnerabilities" in result.metadata
            assert "dependency_vulnerabilities" in result.metadata
            assert isinstance(result.metadata["total_vulnerabilities"], int)
            assert isinstance(result.metadata["dependency_vulnerabilities"], int)

    async def test_query_osv_package_success(self, analyzer):
        """Test querying OSV for any vulnerabilities in a package."""
        vuln = {
            "id": "GHSA-test-vuln",
            "summary": "Test vulnerability",
        }

        mock_response = MagicMock()
        mock_response.json.return_value = {"vulns": [vuln]}
        mock_response.status_code = 200

        with patch("httpx.AsyncClient") as mock_client:
            mock_client.return_value.__aenter__.return_value.post = AsyncMock(
                return_value=mock_response
            )

            vulns = await analyzer._query_osv_package("test-package")

            assert len(vulns) == 1
            assert vulns[0]["id"] == "GHSA-test-vuln"

    async def test_query_osv_package_error(self, analyzer):
        """Test error handling when querying OSV for package."""
        with patch("httpx.AsyncClient") as mock_client:
            mock_client.return_value.__aenter__.return_value.post = AsyncMock(
                side_effect=Exception("Network error")
            )

            vulns = await analyzer._query_osv_package("test-package")

            # Should return empty list on error
            assert vulns == []

    async def test_get_summary_truncation(self, analyzer):
        """Test that vulnerability summary is truncated to 200 chars."""
        long_summary = "A" * 300
        vuln = {
            "summary": long_summary,
            "id": "VULN-123",
        }

        summary = analyzer._get_summary(vuln)
        assert len(summary) <= 200

    async def test_get_summary_uses_id_fallback(self, analyzer):
        """Test summary falls back to ID when not present."""
        vuln = {
            "id": "VULN-999",
        }

        summary = analyzer._get_summary(vuln)
        assert "VULN-999" in summary

    async def test_analyze_with_multiple_vulnerabilities(self, analyzer, sample_metadata):
        """Test analysis with multiple vulnerabilities."""
        vulns = [
            {
                "id": "VULN-001",
                "summary": "First vulnerability",
                "severity": [{"type": "CVSS_V3", "score": "9.0"}],
                "aliases": ["CVE-2023-00001"],
                "affected": [{"ranges": [{"events": [{"fixed": "1.1.0"}]}]}],
                "references": [],
            },
            {
                "id": "VULN-002",
                "summary": "Second vulnerability",
                "severity": [{"type": "CVSS_V3", "score": "7.0"}],
                "aliases": ["CVE-2023-00002"],
                "affected": [{"ranges": [{"events": [{"fixed": "1.2.0"}]}]}],
                "references": [],
            },
        ]

        mock_response = MagicMock()
        mock_response.json.return_value = {"vulns": vulns}
        mock_response.raise_for_status = MagicMock()

        with patch("httpx.AsyncClient") as mock_client:
            mock_client.return_value.__aenter__.return_value.post = AsyncMock(
                return_value=mock_response
            )

            result = await analyzer.analyze(
                "test-package",
                "1.0.0",
                sample_metadata
            )

            assert result.metadata["total_vulnerabilities"] == 2
            # Should have findings for both vulnerabilities
            vuln_findings = [f for f in result.findings if "VULN-" in f.title]
            assert len(vuln_findings) >= 2
